<DOCTYPE! html>
<html>
<head>
 <title>Test HTML</title>
</head>
<body >
<center><h1><u>KTU MCA S1 Web Programming Syllabus</U></h1></center>
<ul>
 <li><h2>Introduction  To  Web:</h2></li>
  <ul> <h3>
   <li><a href="#client"> Client/Server concepts</a></li>
   <li><a href="#compwebapp"> Components  of  Web  Application</a></li>
   <li><a href="#typesofweb"> Types  of Web Content</a></li>
   <li><a href="#reqresp"> Overview of HTTP - HTTP request â€“ response</a></li> 
   <li><a href="#gendyweb"> Generation of dynamic web pages</a></li> 
   <li><a href="#appserver"> Application Servers</a></li>
   <li><a href="#websec"> Web Security</a></li> 
   </h3>
  </ul>


<hr>
<h3><a id="client">1. Client/Server concepts</a></h3>
 <H2>Introduction</H2>


<P>The phrases 'client/server', 'distributed computing'
and 'cooperative processing' have been in use for some time, but
in many ways they are open to interpretation. In fact, the principle
behind client/server computing has been a fundamental part of
the COBOL language since the very beginning, but today's jargon
tends to mask the actual functions being performed.

<P>Essentially, a client is a consumer of services,
and a server provides services. Thus the term 'client' could be
more accurately defined as 'service requester', and server as
'service provider', with the requester 'calling' the provider
for the required service. 

<P><CENTER><IMG SRC="client-server1.GIF"></CENTER>

<P>In COBOL, the CALL statement is the method used to
invoke such requests, but the similarity between the standard
CALL statement and client/server functionality may not always
be immediately apparent.

<P>The CALL statement is usually associated with calls
to local functions (that is, CALLed programs which reside on the
same machine as the CALLing program), which can be regarded as
services. Thus, CALLing a date validation routine is actually
requesting a validation service from a particular module.

<P>CALLs don't necessarily have to be to local functions;
they can be made to remote functions (that is, CALLed programs
located on a different machine from the CALLing program). These
are often referred to as 'remote procedure CALLs' or RPCs.

<P>The client/server model extends the COBOL CALL scenario
in the following ways:
<UL>
<LI>Many subprograms can be grouped to provide the
'service'.
<LI>The client does not necessarily need to be aware
of the actual subprograms which comprise the service.
<LI>A server can provide multiple services.
<LI>Multiple clients can request services from a
single server.
<LI>The location of the server program is typically
remote (that is, on a separate machine) from the requesting program.
<LI>A single client can request services from multiple
servers.
</UL>


<P>Several distributed processing functions, such as
presentation logic (screen handling), business logic (data processing)
and data access (file/database manipulation), logically suggest
themselves as candidates for the client/server model. Middleware
(communications/transaction processing) is then needed to connect
these distributed functions.

<P>Micro Focus provides products and technologies to
address all of the client/server application development and deployment
areas listed above.
<H2><A NAME="_TOC355664795">Client/Server Benefits</A></H2>


<P><A NAME="_TOC339183629">This section looks at the
benefits of a client/server architecture.</A>

<P>If your mission-critical applications suffer from
heavy processor burden, poor or outdated user interfaces, total
reliance on one or two pieces of hardware, or are just not taking
advantage of newer and faster technology, then it is worth considering
migrating to a client/server architecture to resolve some or all
of these problems.

<P>By using Micro Focus tools and services, you can
implement a complete application solution that leverages the power
of existing servers, while exploiting the large installed base
of desktop lower-end client systems.

<P>You should consider creating an application or migrating
existing code to a client/server architecture if you wish to fulfill
one or more of the following strategic criteria:
<UL>
<LI>Replace a character I/O interface with a graphical
user interface (GUI), for example replacing 3270 screens on a
mainframe application with a GUI front end.
<LI>Locate the existing business processing rules
on scaleable, multi&#173;processor UNIX systems tuned for multi-user
and high-performance RDBMS access.
<LI>Use existing mainframe business processing and
data capabilities on non-mainframe environments (for example,
PC, and UNIX).
<LI>Control access to a limited resource.
<LI>Spread the computational load in order to maximize
responsiveness.
<LI>Choose separate platforms which provide the optimum
solution for each application component instead of having to compromise
on a single platform for all components or having to port each
component to a single platform.
<LI>Fully utilize the power of PC desktop systems.
<LI>Enable appropriate local client data manipulation
and processing.
<LI>Increase accessibility of applications (for example,
provide a PC front end to a UNIX only application).
<LI>Add new systems without adding to the mainframe
load.
<LI>Reduce administration costs by centralizing administrative
tasks.
</UL>


<P>The respective benefits and strategic criteria will
depend upon your existing business system architecture and available
resources.

<H2><A NAME="_TOC355664796">Client/Server </A>Architectures</H2>


<P><A NAME="_TOC339183630">The size and complexity of
your application will determine how widely its components should
be distributed in order to make the most efficient use of the
platforms and networks.</A>

<P>This section discusses common client/server architectures
- that is the structure or design for distributing the different
application elements: presentation logic, business logic and data
access. These distributed architectures are commonly referred
to as two-tier, three-tier, or<I> n</I>-tier. There are generally
two schools of thought regarding the definition of a tier:
<OL>
<LI>A tier is a distinct element of the application
which can be (but doesn't necessarily have to be) distributed
across a network.


<P>Once the application has been modularized, the tiers
can be put on separate machines and connected via networks. However,
tiers don't have to be distributed, they can be run on a single
machine as a standalone application.

<LI>A tier refers to a platform. An application element
runs on a specific tier of the network, so once the application
has been modularized, the elements must be deployed on distinct
physical hardware for the application to be considered tiered.


<P>For example, the data access element typically resides
on a data server (for example, a mainframe), the business logic
element on an application server (for example, a UNIX machine,
Windows NT or OS/2 PC) and the presentation logic element on a
client (for example, a Windows PC).
</ol>


<P>Regardless of the school of thought, the application
must be logically partitioned. This document assumes that logical
partitions are also physically partitioned.

<P>There are typically two models of a two-tier client/server
architecture:
<UL>
<LI>Thick client two-tier architecture: the majority
of the application's business logic resides with the presentation
logic on the client, with the data access portion on the server.
<LI>Thin client two-tier architecture: only the application's
presentation logic resides on the client, with the data access
and the majority of the business logic on the server.
</UL>


<P>In a three-tier architecture, the application is
typically partitioned into three separate units: presentation
logic, business logic and data access.

<P>Tiers located on separate machines are connected
via networks, such as Local Area Networks (LANs), Wide Area Networks
(WANs), Systems Network Architecture (SNA) or telephone networks.

<P>Figure 1-1 illustrates some typical client/server
architectures; it doesn't show every conceivable distribution
of application elements or platform choice. The models can be
combined or extended beyond 3-tier to <I>n</I>-tier architectures
as best suits your needs. Further details on the platforms available
are provided in the section <CITE>Platform
Choices</CITE>.<BR>



<P><CENTER><img border=1 src="client-server2.GIF"></CENTER>

<P><center>Figure 1-1 : Typical Client/Server Architectures </CENTER>

<H2><A NAME="_TOC355664797">Middleware Considerations</A></H2>


<P>As noted in the previous section, tiers located on
separate machines are connected via networks. Middleware products
typically provide a range of services which allow transparent
access to resources in a network. 

<P>Micro Focus technology allows you to mask the individual
network APIs found with every network protocol provider and to
mask the operating system APIs for each of these network providers.
This is achieved by providing a single common interface on all
protocols and operating systems.

<H2><A NAME="_TOC355664798">Platform Choices</A></H2>


<P>This section examines the variety of platforms you
can use in implementing a typical client/server solution. Since
one of the primary benefits of a client/server architecture is
the ability to use the best machine for each job, you can choose
the most suitable platform for your presentation logic, business
logic and data access.

<P>For client platforms, which typically contain the
presentation logic (and perhaps portions of the business logic),
the choice is typically made from DOS, Windows 3.1, Windows 95,
Windows NT, or OS/2.

<P>Server platforms, which typically contain the business
logic and data access elements, are selected according to application
throughput requirements. Depending on your needs, you can select
from a range of low- to medium-end platforms, such as Windows
NT, OS/2, NetWare or single or multiprocessor UNIX systems through
to high-end servers such as superminis or mainframes.

<P>Most platforms could function as both client or server,
but Table 1-1 lists the types of platforms commonly used in implementing
a
Micro Focus Client/Server solution.

<P><TABLE BORDER=1>

<TR><TD WIDTH=360><B>Platform</B></TD><TD WIDTH=90><CENTER><B>Client</B></CENTER>
</TD><TD WIDTH=90><CENTER><B>Server</B></CENTER></TD></TR>

<TR><TD WIDTH=360>Dumb Terminal</TD><TD WIDTH=90><CENTER>Y</CENTER>
</TD><TD WIDTH=90><CENTER>-</CENTER></TD></TR>

<TR><TD WIDTH=360>DOS</TD><TD WIDTH=90><CENTER>Y</CENTER></TD>
<TD WIDTH=90><CENTER>-</CENTER></TD></TR>

<TR><TD WIDTH=360>Windows 3.x, Windows 95</TD><TD WIDTH=90><CENTER>Y</CENTER    >
</TD><TD WIDTH=90><CENTER>-</CENTER></TD></TR>

<TR><TD WIDTH=360>Windows NT</TD><TD WIDTH=90><CENTER>Y</CENTER>
</TD><TD WIDTH=90><CENTER>Y</CENTER></TD></TR>

<TR><TD WIDTH=360>OS/2</TD><TD WIDTH=90><CENTER>Y</CENTER></TD>
<TD WIDTH=90><CENTER>Y</CENTER></TD></TR>

<TR><TD WIDTH=360>NetWare</TD><TD WIDTH=90><CENTER>-</CENTER></TD>
<TD WIDTH=90><CENTER>Y</CENTER></TD></TR>

<TR><TD WIDTH=360>UNIX</TD><TD WIDTH=90><CENTER>-</CENTER></TD>
<TD WIDTH=90><CENTER>Y</CENTER></TD></TR>

<TR><TD WIDTH=360>Mainframe</TD><TD WIDTH=90><CENTER>-</CENTER>
</TD><TD WIDTH=90><CENTER>Y</CENTER></TD></TR>

</TABLE>
Table 1-1 :  Typical Client/Server Platforms

<P>The platform you choose for each tier depends upon the particulars
of your application, such as where your existing application currently
resides; where your presentation logic, data access and business
logic currently reside and where you plan to relocate them; what
type of platforms are currently available or planned for your
users; and what your level of experience is in client/server development.
The following sections describe a number of scenarios experienced
by Micro Focus customers.
<H3><A NAME="_TOC355664799">Migrating from the Mainframe to Enterprise
Client/Server</A></H3>


<P>Often a large mainframe-oriented company first decides
to test the waters of client/server by using the DS3270 facility
of Dialog System to implement a graphical front end for existing
3270 applications. DS3270 maps the 3270 screens on the mainframe
to Dialog System screensets on PCs; that is, the GUI interface
is deployed on PCs, while the application itself remains on the
mainframe.

<P>The next stage is often to rehost all or part of
the existing application from the mainframe. For example, the
application's business rules are migrated to a UNIX server.

<P>Finally, experienced development organizations anticipate
these changing requirements, so they design and create new applications
based on a flexible client/server architecture from the outset,
deploying application components on the most suitable platform.
<H3><A NAME="_TOC355664800">Migrating from UNIX to Enterprise
Client/Server</A></H3>


<P>A UNIX oriented MIS department or an ISV may have
a standalone UNIX application which it decides to extend to a
client/server architecture to meet its users' needs.

<P>The application's character user interface may have
been hardcoded for display on a UNIX dumb terminal. A typical
first step is to separate out the user interface using character
Dialog System to provide a more user friendly interface using
Dialog System's windowing facilities.

<P>The next step is often to replace the character interface
with a graphical user interface using GUI Dialog System in order
to take full advantage of graphical PCs.

<P>Separating out the data access portion of the application
onto a server to allow improved data sharing or to host the data
access on a more appropriate data server may be the following
step.

<P>There may also be demand to move data access to the
mainframe or to integrate departmental data with existing corporate
data on the mainframe; that is, to have the data server or part
of the data server located on the mainframe.

<P>Finally, experienced development organizations again,
will want to anticipate these changing requirements, so they design
and create new applications based on a flexible client/server
architecture from the outset.
<H3><A NAME="_TOC355664801">Migrating from the PC to Enterprise
Client/Server</A></H3>


<P>Often a small company's MIS department or an ISV
may have developed a standalone PC application which it needs
to extend to a client/server architecture to meet its users' needs.

<P>The application may have been created with a hardcoded
character user interface. The first step may often be to modernize
the application by splitting out the user interface in order to
implement a GUI interface or just to ease application maintenance.

<P>The next step may be to separate out the business
logic and host this on a high performance multi-user UNIX server,
thereby taking advantage of the higher processing power and easing
the roll out of fixes or new versions of the application business
logic.

<P>There is then often demand to move data access to
the mainframe or to integrate departmental data with existing
corporate data on the mainframe; that is, to have the data server
or part of the data server located on the mainframe.

<P>Again, experienced development organizations anticipate
these changing requirements, so they design and create new applications
based on a flexible client/server architecture from the outset.
<H3><A NAME="_TOC355664802">Creating New Client/Server Applications</A>
</H3>


<P>Whether you are migrating to client/server from a
mainframe, UNIX or PC background, you will typically end up creating
new applications based on a client/server architecture.

<P>The remainder of this document focuses on how you
create a new Dialog System client/server application, describing
the Micro Focus tools you need and how you actually implement
an application.

<P>Much of the information will still be of use to anyone
trying to understand how to migrate existing applications.<BR> <hr>


<h3><a id="compwebapp">2. Components of Web Application</a></h3>
<p>Web application architecture comes with two types of web application architecture: Structural components, and user interface app components.

<ul>
<li>Structural Components:</li>
<p>As the name suggests, these components make the structure of the application. These components include the client or web browser, database server, and web app server which are directly responsible for functions deciding the user interactions within the application. In the majority of cases, JavaScript, CSS, and HTML are used to create these components. However, it all varies with the web app developer.</p>
<li>User Interface Components:</li>
<p>The other one is the user interface components that contribute to the visual interface of the app. However, unlike structural components, that do not interact with the architecture, but are limited to displaying the web page. These components include a dashboard, widget, settings, notifications, and many other visual elements that help in making the user experience better. In other words, these components are directly responsible for the UX or the web app.</p> <br> <hr>
</ul>

<h3><a id="typesofweb">3. Types  of Web Content</a></h3>

Web content is the text, visual or audio content that is made available online and user encountered as part of the online usage and experience on websites. It may include text, images, sounds and audio, online videos, among other items placed within web pages.<br>

In the book Information Architecture for the World Wide Web, Lou Rosenfeld and Peter Morville wrote, "We define content broadly as 'the stuff in your website.' Web content may include webpage document pages, information, software data and applications, e-services, images, audio and video files, personal Web pages, archived e-mail messages stored on email servers, and more. And we include future web content as well as present web content roadmap.<br>
<h4>Content Management</h4>

Because websites are often complex, a term "content management" appeared in the late 1990s identifying a method or in some cases a tool to organize all the diverse elements to be contained on a website.[2][better source needed] Content management often means that within a business there is a range of people who have distinct roles to do with content management, such as content author, editor, publisher, and administrator. But it also means there may be a content management system whereby each of the different roles is organized to provide their assistance in operating the system and organizing the information for a website. A business may also employ various content protection measures, which are typically technologies used to attempt to frustrate copying without permission. <br> <hr>

<h3><a id="reqresp">4. Overview of HTTP - HTTP request â€“ response</a></h3>
<pre>
HTTP Messages

HTTP messages are how data is exchanged between a server and a client. There are two types of messages: requests sent by the client to trigger an action on the server, and responses, the answer from the server.

HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.

Web developers, or webmasters, rarely craft these textual HTTP messages themselves: software, a Web browser, proxy, or Web server, perform this action. They provide HTTP messages through config files (for proxies or servers), APIs (for browsers), or other interfaces.

From a user-, script-, or server- generated event, an HTTP/1.x msg is generated, and if HTTP/2 is in use, it is binary framed into an HTTP/2 stream, then sent.

The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.

HTTP requests, and responses, share similar structure and are composed of:

    A start-line describing the requests to be implemented, or its status of whether successful or a failure. This start-line is always a single line.
    An optional set of HTTP headers specifying the request, or describing the body included in the message.
    A blank line indicating all meta-information for the request has been sent.
    An optional body containing data associated with the request (like content of an HTML form), or the document associated with a response. The presence of the body and its size is specified by the start-line and HTTP headers.

The start-line and HTTP headers of the HTTP message are collectively known as the head of the requests, whereas its payload is known as the body.

Requests and responses share a common structure in HTTP
HTTP Requests
Start line

HTTP requests are messages sent by the client to initiate an action on the server. Their start-line contain three elements:

    An HTTP method, a verb (like GET, PUT or POST) or a noun (like HEAD or OPTIONS), that describes the action to be performed. For example, GET indicates that a resource should be fetched or POST means that data is pushed to the server (creating or modifying a resource, or generating a temporary document to send back).
    The request target, usually a URL, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be
        An absolute path, ultimately followed by a '?' and query string. This is the most common form, known as the origin form, and is used with GET, POST, HEAD, and OPTIONS methods.
            POST / HTTP/1.1
            GET /background.png HTTP/1.0
            HEAD /test.html?query=alibaba HTTP/1.1
            OPTIONS /anypage.html HTTP/1.0
        A complete URL, known as the absolute form, is mostly used with GET when connected to a proxy. GET https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1
        The authority component of a URL, consisting of the domain name and optionally the port (prefixed by a ':'), is called the authority form. It is only used with CONNECT when setting up an HTTP tunnel. CONNECT developer.mozilla.org:80 HTTP/1.1
        The asterisk form, a simple asterisk ('*') is used with OPTIONS, representing the server as a whole. OPTIONS * HTTP/1.1
    The HTTP version, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.

Headers

HTTP headers from a request follow the same basic structure of an HTTP header: a case-insensitive string followed by a colon (':') and a value whose structure depends upon the header. The whole header, including the value, consists of one single line, which can be quite long.

Many different headers can appear in requests. They can be divided in several groups:

    General headers, like Via, apply to the message as a whole.
    Request headers, like User-Agent or Accept, modify the request by specifying it further (like Accept-Language), by giving context (like Referer), or by conditionally restricting it (like If-None).
    Representation headers like Content-Type that describe the original format of the message data and any encoding applied (only present if the message has a body).

Example of headers in an HTTP request
Body

The final part of the request is its body. Not all requests have one: requests fetching resources, like GET, HEAD, DELETE, or OPTIONS, usually don't need one. Some requests send data to the server in order to update it: as often the case with POST requests (containing HTML form data).

Bodies can be broadly divided into two categories:

    Single-resource bodies, consisting of one single file, defined by the two headers: Content-Type and Content-Length.
    Multiple-resource bodies, consisting of a multipart body, each containing a different bit of information. This is typically associated with HTML Forms.

HTTP Responses
Status line

The start line of an HTTP response, called the status line, contains the following information:

    The protocol version, usually HTTP/1.1.
    A status code, indicating success or failure of the request. Common status codes are 200, 404, or 302
    A status text. A brief, purely informational, textual description of the status code to help a human understand the HTTP message.

A typical status line looks like: HTTP/1.1 404 Not Found.
Headers

HTTP headers for responses follow the same structure as any other header: a case-insensitive string followed by a colon (':') and a value whose structure depends upon the type of the header. The whole header, including its value, presents as a single line.

Many different headers can appear in responses. These can be divided into several groups:

    General headers, like Via, apply to the whole message.
    Response headers, like Vary and Accept-Ranges, give additional information about the server which doesn't fit in the status line.
    Representation headers like Content-Type that describe the original format of the message data and any encoding applied (only present if the message has a body).

Example of headers in an HTTP response
Body

The last part of a response is the body. Not all responses have one: responses with a status code that sufficiently answers the request without the need for corresponding payload (like 201 Created or 204 No Content) usually don't.

Bodies can be broadly divided into three categories:

    Single-resource bodies, consisting of a single file of known length, defined by the two headers: Content-Type and Content-Length.
    Single-resource bodies, consisting of a single file of unknown length, encoded by chunks with Transfer-Encoding set to chunked.
    Multiple-resource bodies, consisting of a multipart body, each containing a different section of information. These are relatively rare.

HTTP/2 Frames

HTTP/1.x messages have a few drawbacks for performance:

    Headers, unlike bodies, are uncompressed.
    Headers are often very similar from one message to the next one, yet still repeated across connections.
    No multiplexing can be done. Several connections need opening on the same server: and warm TCP connections are more efficient than cold ones.

HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, which allows header compression. Several streams can be combined together, a process called multiplexing, allowing more efficient use of underlying TCP connections.

HTTP/2 modify the HTTP message to divide them in frames (part of a single stream), allowing for more optimization.

HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</pre>


</body>
</html>
  
